# busboy-async

An asynchronous generator for busboy events.

# Description

`busboy` is a Node.js package for parsing multi-part HTML form data,
which is implemented to communicate form values to the package user
via callbacks. `busboy-async` is based on `busboy` and provides an
asynchronous generator returning form values in the order of their
appearance within the form submission request.

One of the advantages of using an asynchronous generator vs. more
traditional callbacks is that there is no need to use `Readable.pipe`
or similar methods to obtain form values and a data stream, so
the data stream may be processed outside of callbacks, and may be
intermixed with validation and request processing code in a more
maintainable `async`/`await` fashion.

# Example usage

HTML form controls are submitted in their DOM order, so arranging
form controls such that the file input is located last within
a form allows one to construct a request argument object, which
may be validated via `Joi` or similar packages, and then process
the data stream in the backend code in a similar way as a regular
form submission or an API call would be processed.

This example uses Express just exposition. `busboy-async` depends
only  on `busboy` and Node.js streams.

```TypeScript
import { BusboyAsync, BusboyAsyncEvent } from "busboy-async";

async function on_image_put(req: express.Request,
                            res: express.Response,
                            next: express.NextFunction) : Promise<void>
{
    try {
        res.set("Content-Type", "application/json");

        let reqArgs: Record<string, any> = {};

        let imageContentType: string|undefined = undefined;
        let imageStream: stream.Readable & {truncated?: boolean}|undefined = undefined;

        let busboyAsync = new BusboyAsync({headers: req.headers});

        // resolves when all events generated by busboy are returned from the asynch generator
        let busboyDone: Promise<void> = busboyAsync.feedBusboy(req);

        // need a standalone variable, so the loop can be interrupted to process file streams
        let busboyEvents: AsyncGenerator<BusboyAsyncEvent> = busboyAsync.busboyEvents();

        // loop until we encounter the file stream for a file input
        for await (let bbEvent of busboyEvents) {
            if(bbEvent.eventType == "field") {
                if(bbEvent.fieldName == "csrf")
                    reqArgs.csrf = bbEvent.fieldValue;
                else if(bbEvent.fieldName == "size")
                    reqArgs.size = bbEvent.fieldValue;
            }
            else if(bbEvent.eventType == "file") {
                if(bbEvent.fieldName == "image") {
                    // file input field name
                    reqArgs.name = bbEvent.fieldName;
                    // original file name, if present (use with care - may be malicious)
                    reqArgs.filename = bbEvent.filename;

                    imageContentType = bbEvent.mimeType;
                    imageStream = bbEvent.fileStream;

                    // break out to process the request and finalize reading the rest of the args after
                    break;
                }
            }
            else if(bbEvent.eventType == "limit") {
                res.status(400).json({status: "error", message: `Too many ${bbEvent.limitName}`});
                return;
            }
        }

        if(imageStream == undefined) {
            res.status(400).json({status: "error", message: "Missing image data"});
            return;
        }

        // validate form fields as usual (the file field may be checked via Joi.any())
        let reqQuery = joiImagePut.validate(reqArgs, joiValidateOptions);

        if(reqQuery.error) {
            res.status(400).json({status: "error", message: reqQuery.error.message});
            return;
        }

        validateCsrf(reqQuery.value.csrf);

        //
        // Upload size may not be required and may be computed while
        // the data stream is being processed, but for some uses this
        // would require saving it to the file first. Passing data
        // size explicitly allows to use this mechanism to save data
        // in AWS S3, for example, and without using intermediate
        // local storage.
        //
        const imageSize: number = reqQuery.value.size;

        //
        // imageStream is a custom busboy stream that will have an
        // optional `truncated` field if the file limit is exceeded,
        // a `bytesRead` field to track how much data was read, and
        // will emit a `limit` event if the file is larger than the
        // allowed limit and has been truncated. When this event is
        // emitted, it will be done in the context of the file stream
        // and *not* the context of the multipart form stream shown
        // in this example.
        //
        processImageStream(imageStream, imageContentType, imageSize, reqQuery.value.filename);

        // must continue the same loop to consume all events (e.g. exceeded limits or more files)
        for await (let bbEvent of busboyEvents)
            handleBusboyAsyncEvent(bbEvent);

        // wait for busboy to finalize the parsing stream
        await busboyDone;

        res.json({status: "success"});
    }
    catch (err) {
        next(new httpError.InternalServerError());
        return;
    }
}

```
